import { Bun } from 'bun';
import { extractImagePrompts } from './utils';
import type { Client } from './client'; // Type-only import to prevent circular dependency issues
import type { StreamChunk, ApiImageAttachment } from './types';

/**
 * Represents a single image attachment generated by Grok.
 */
export class Attachment {
    private _client: Client;
    private _bytes_cache: Buffer | null = null;

    public url: string;
    public mediaId: string;
    public fileName: string;
    public mimeType: string;

    constructor(client: Client, data: ApiImageAttachment) {
        this._client = client;
        this.url = data.imageUrl;
        this.mediaId = data.mediaIdStr;
        this.fileName = data.fileName;
        this.mimeType = data.mimeType;
    }

    /**
     * Fetches the raw image data as a Buffer.
     * The result is cached in memory for subsequent calls.
     * @returns A Promise that resolves to a Buffer containing the image data.
     */
    public async fetchBytes(): Promise<Buffer> {
        if (this._bytes_cache) {
            return this._bytes_cache;
        }
        // This relies on a `getGrokImage` method we will define on the Client.
        const fileBytes = await this._client.getGrokImage(this.url);
        this._bytes_cache = fileBytes;
        return fileBytes;
    }

    /**
     * Extracts the embedded prompts from the image data.
     * @returns A Promise that resolves to a tuple [prompt, upsampledPrompt].
     */
    public async getPrompts(): Promise<[string, string]> {
        const imageBytes = await this.fetchBytes();
        return extractImagePrompts(imageBytes);
    }

    /**
     * Downloads the attachment to a local file.
     * @param filePath - The path where the file should be saved.
     */
    public async download(filePath: string): Promise<void> {
        const fileBytes = await this.fetchBytes();
        await Bun.write(filePath, fileBytes);
    }

    public toString(): string {
        return `<Attachment media_id="${this.fileName}">`;
    }
}

/**
 * Represents the complete, generated content from a Grok conversation stream.
 */
export class GeneratedContent {
    public chunks: StreamChunk[];
    public conversationId: string | undefined;
    public userChatItemId: string | undefined;
    public agentChatItemId: string | undefined;
    public message: string;
    public attachments: Attachment[];
    public followUpSuggestions: string[];

    constructor(client: Client, chunks: StreamChunk[]) {
        this.chunks = JSON.parse(JSON.stringify(chunks)); // Deep copy like the original

        const initialChunk = chunks.shift();
        this.conversationId = initialChunk?.conversationId;
        this.userChatItemId = initialChunk?.userChatItemId;
        this.agentChatItemId = initialChunk?.agentChatItemId;

        let message = '';
        const attachments: Attachment[] = [];
        const followUpSuggestions: string[] = [];

        for (const chunk of chunks) {
            if (!chunk.result) {
                continue;
            }
            const { result } = chunk;

            if (result.message) {
                message += result.message;
            }

            if (result.imageAttachment) {
                attachments.push(new Attachment(client, result.imageAttachment));
            }

            if (result.followUpSuggestions) {
                followUpSuggestions.push(...result.followUpSuggestions);
            }
        }

        this.message = message;
        this.attachments = attachments;
        this.followUpSuggestions = followUpSuggestions;
    }

    public toString(): string {
        return `<GeneratedContent id="${this.userChatItemId}">`;
    }
}